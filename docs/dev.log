
2021/09/26
・ito-nstepsを追加した
　繰り返しito-kamnagi.lispをloadすると、ito-countupの結果が狂ってエラーになった。
　それは当然。気をつけよう

　ito-nsetpsでは、一回のstep-modelで、すべてのportの計算が終わった。
　mod1のcompoの順番を逆にすると、おきない。
　つまり、portの値の変化が次のcompoの実行に影響してしまっている。
　順番に依存しないようにしたいならば、
　portの値は、step-modelを実行する前の値を使わなくてはならない。
　それとも、これでよいと考えられるのか?　compoの順に値が波及していくところを見たいのでNO

　compoの計算結果は一旦keepしておいて、step-modelのあとにそれをportに設定するのがよさそう。
　あるいはstep-modelの前の値をbackupして、step-model/step-compoの計算中のinput側の値は
　そこから参照するようにするか
  一旦残しておくのはめんどうなので、propertyに置くことにしよう。

　apres : あとの値、avant: 前の値

　apresだと、compoの計算結果をいったんそこに置くことになる。
　そして、skip-modelの最後にapresの値をportのvalueとして設定する。
　このportは*portlist*でなくcompoのoutput(input)にあがっているportになるので
  step-modelでは要素のcompoのinputまたはoutputを管理する必要がありそう。

　ならば、*portlist*の全portについてこの操作をすればよい。
　　portが10000個くらいあって、compoで使うのがそのうちの数10個だと効率が悪いが・・・
　　
  apresの場合は、step-modelの最後に*portlist*のすべてについて
    multiple-value-setのとき、valueでなくproperty apresに設定し
　　step-modelの最後に apresからvalueに設定しなおす

　avantの場合は、step-modelの最初に*portlist*のすべてのportについて
　  valueをavantに設定し、
　　inputの値はvalueでなくavantからとってくるようにする。
　　collectvalueの参照先をかえる。

　collectvalueがすでにあるので、avantのほうが修正は少なくてよいようなきがする。
  collectvalueはcompoの中でなく、step-modelでやらなくてはならない。

　defcompoでmultiple-value-setしているところをどうにかするのかな

　問題点は2つ。
　1. step-modelの前後のどちからで値をkeepし、step-modelの期間中の順番を無効にする
　2. step-compoもその影響をうける

** collectvaluesを作っているので、outputをbackupするよりinputをbackupするほうが多少よさそう

step-model起動時のportの値を格納するプロパティ名は
 :before
にする。

にもかかわらず、ito-nstepsの結果はかわらず


2021/09/27
ito-nsteps の結果がかわらないのは、beforeに設定した値をstep-compoで参照していないからだろう
collectvaluesをget-beforesという名前にして:beforeから値をとってくるようにした。

この修正で、ito-kamnagi.lispの前の方のitoで、step-compoをしていたところは
:beforeが必要になるのでstep-modelに置き換えた


* この修正の問題点
　ito-loop1のように、step-model中に変更された値p32,p33をほかで参照していたら
　その値はbeforeになってしまう。
 
2021/09/29
夜、寝ている時に気づいたが、今の動作で正解なので、意図を訂正した

beforeという名前はよいのか、迷い中。

* 夜
まず、portの名前を与えて、その値のリスト(性能情報の一行分)をlistにする。

それを繰り返して、セッション中のlogsをあつめる。すなわち

portの値をlistに取り出して、それをlistにpushしていく。
play-kamnagi.lisp

(defvar logs  (nstep-model 10  *portlist*  mod31))

で10回回転する。

ただし、tsはどうも他の変数と別の扱いをすべきなのかも。
ts自体はどうでもいいので、日付でおきかわるから。
portのtsでも、nstep-modelのnでもよい。
tsをcompoで計算しなくてもよいと思う。
でも、時間によって値が影響をうけるようなcompo/portを作りたい時はts portか
それに似たものが必要になる。
tsが問題なのは、compoの実行後のtsとmodelの途中のtsはひとつずれているということ。

ここまではplay-kamnagi.lispできた。

次は
1. csvファイルに出力する。
　すみ
2. 項目名をつける
　すみ
3. datetime 文字列を生成する
　　formatをあえる。y,m,d,h,mm,ss,msのようなキーワード。
　　順番に生成する。
　　　・月によって日数がかわる。m,dの桁あがり。
　　　・閏年がある。


2021/10/02土
datetimeの生成はややこしい。ので、分割して作っていく。
[ややこしさ]
・1日未満の場合
　　sec,min,hour <24H
　　比較的単純
　　nsecかもしれないが、とりあえず最小はsecとする。

    範囲であり繰り上がりのトリガー
　　sec  0<= sec <60
　　min  0<= min <60
　　hour 0<= hour <24

・1日から年
　- 閏年

　- 月によって日数がかわる
　　1 => 31
　　2 => 28,29 閏年に依存
　　3 => 31
　　4 => 30
　　5 => 31
　　6 => 30
　　7 => 31
　　8 => 31
　　9 => 30
　　10 => 31
　　11 => 30
　　12 => 31

　　にしむくさむらい小の月

・生成は、ある時刻のあと次の時刻をどのような間隔で作るかをコントロールしたいかどうか
　基本は、固定の間隔でよい。
　　例えば、5分間隔なら、0:04, 0:09, 0:14, ... この場合、0:59がその分の中の最後の秒になる。

　固定を変えられる(より実際のデータに近づけたい場合。本当に必要かどうかは不明)
　　次のイベントまでの時間を正規分布で変えられるようにするとすると
　　　(m, s)で、平均の間隔がm、分散がsと指定する。
  この分布を正規以外にしたいか??

　この場合、繰り上がりは実際に計算してみないと、決まらない。

- これらのことから、生成APIに必要なパラメータ
　0-datetime  : 最初の時刻
　間隔指定    : dとか(f, d,s)とか。fは分布におうじて計算する関数
　

　|-- 桁あがりの範囲 --| 今 |-- 間隔内の時間 --|

　　間隔内の時間が0とは限らないのではないか?どの範囲までコントロールしたいか。それは分布で決まるのか?

　　桁あがりで、閏年や月の日数による計算をどうするか



2021/10/03日
・乱数関係はquicklispでcl-randistというのがあった。

thanks to https://github.com/lvaruzza/cl-randist

　このソースの中のtests.lispを動かすとなにかできている。
  (ql:quickload "cl-randist")
　(in-packakge :randist)で使える
　どの関数で正規分布での乱数発生できるのか不明。
　(load "tests.lisp")の中にtest-distがあって、平均と分散を見れるので
  (gen-uniform 100)で、一様分布の乱数が10個作られる

　tests.lispのコメントの中に正規分布ぽいのがある

  (gen-normal 10)で10個作れるが、平均と分散の指定はできないみたい。

 (defun gen-normal (&optional (n 100))
  (genlist #'(lambda (x) (declare (ignore x)) (random-normal)) n))

　1個だけ平均、分散を指定して乱数を作る関数はこれ。
　平均100、分散10の正規分布での乱数は
　 (random-normal 100.0d0 10d0)
　で計算できる。数字末尾のd0は、double floatを示す
　
  (random-uniform)もあるが、こちらは引数なし。

2021/10/07木
・datetimeの生成(制限付き)を作った
　うるう年とか大の月小の月などは無視し、year-monの部分は固定で日以下だけをインクリメントする
day.lispを作った。

・day+dayは作ったが、day-dayは逆向きのキャリーが発生するので未対応。
　当初の制約条件的な正規化のほうがよかっただろうか。

・モデルを作ってみる。
   image/model101.JPG

2021/10/08
model101-kamnagi.lispで、ひととおり動かした。
カレンダー部分は狂っているが、処理はできた。

・2/29のうるう年処理
・大小月の:w

day.lispに月の日数計算を追加した。

・閏年、大小月のことを考えると、今のやりかたは過剰に一般化しているのではないか。

何が必要な条件なのかを明確にすべき
・タイムスタンプの表記順が違うというのは、内部形式に変換して計算すればよいので問題外
　　だが、内部形式に変換する機能はいるのか?(タイムスタンプを生成するだけなので、内部形式からはじめれば
　　そういう問題はそんなにない)

[考えている要求]
　・年や月をまたぐようなタイムスタンプが作れる。
　・１日の範囲で秒単位のタイムスタンプを作る。
　・閏年にかかわるようなタイムスタンプを作ることはありそうだが、100年400年の例外にあたることは
　　とうぶんなさそう(2021年現在)だが、サンプルデータを作る時はほしいかもしれない。
　・発生時間の間隔を指定したい
　　　- 固定間隔(たえば15分ごととか)を指定する
　　　- 間隔時間の分布を指定したいかも。たぶん、正規分布でよいかも。

　・時間を発生するコンポを作った場合、データ回収のタイミングがずれているので、タイムスタンプが
　　ずれてしまう。だから、タイムインデックスはKamnagi自体が管理し、それをコンポにうけわたす。
　・タイムスタンプをインデックスとして実装しているが、カレンダー情報(Y M D h m s)を渡すほうが
　　コンポ側で詳細な制御ができるようになるので望ましいのではないか?
　　　たとえば、月曜の負荷とか金曜の負荷といった曜日に依存するようなシステム構成を真似したい場合。
　　　朝と昼と夜で異なるコンポ
　　　これはKamnagiのバージョンアップ時に考えれば良い。

[問題になっていること]
　・時間インデックスをコンポで発生させると、データの収集をstepの最後に行った時、データの発生した
　　時刻が次の時刻になってしまう。そのため、タイムスタンプ情報はkamnagiが与えるようにした。
　・

[機能仕様]
　・1ステップの実行は、各コンポのステップ初期値によって決まる変化しか想定しない。
　　つまり、ステップの実行中に変化したコンポの値というものは次のステップにしか影響しない。
　・

[コードの制約]
　・基本的に一般化したい(コードを減らし、理解しやすくするため)が、仕様に応じて過剰な一般化は無意味だ。


2021/10/09
・day.lispの大きな考え方は、(+ day1 day2)の計算を
  1. 個々のd in dayについて、(+ d1 d2)を計算する。
　2. 1で求めた各単位をそれぞれのmaxesでmodをとる。桁あがりは右側の要素としている。
　　　右側にしているのはfor-inでまわしているからと、maxesの順番による。
　　　また、(Y M D h m s)の順番にするために、reverseにしてからplusし、結果をまたreverseしている。

・maxesが変化することになったので、maxesは数字でなく関数にしてみようか。
　そのとき何をかえればよいのか?

　　・まず、reverseしないようにして、右側から順に計算する。(これは+deltaであればよいが、-deltaに
　　　なるとまずい。しかし、現実では時間は先にすすむだけなので、ここは+のことだけ考えよう)

　　・maxesを求めるために、うるう年を考えると、年月が何かが必要。
　　　他の月は月ごとにmaxesは決まっている。
　　　日以下のデータは、日時分秒でmaxesが決まっている。

　　　というばらつきがある。
　　　ということは呼び出し側もかわる。

　　　もし dt=(Y M H h m s)について正規化するとき、(norm dt)という見かけにするとすると
　　　このレベルでは特に問題ない。、

　　　この中のここのunitについてかわる。
　　　(norm-unit x dt)
　　　という見かけだとすると、今、どのunitをするのかがわからない。ので、xにはunitが必要。
　　　かといってunitをつけて、carryがはいるunitをその構造にもたせるのは過剰なきがする。
　　　いままではこれをmaxesの順番で対処していた。

　　　それをやめるとすると、どうなるか?

　　　(normal-fix x 60) 60 は24とかもある。

      (normal-mon x f)
　　　　f when month 
　　　　dayの計算時、monthのmodが必要になる。
　　　　たとえばhourの計算は、dayのmodで切る。個別に何時かは関係ない。

　　　　28日+1を計算したとき、それが2月である情報が必要になる。
　　　　毎月この処理をするか、2月のときのmaxを決めておくか。という選択肢もありうる。
　　　　そして2月のmaxを計算するとき、年の情報が必要になる。

　　　　(年、月)で各月のmaxが決まるともいえるし、2月のmaxだけかわるとも言える。

　　　　一年が255か256かは、2/29があるかないかで決まるので、閏年かどうかを年の区切りで考える必要はない。
　　　　月については、12固定である。

  max   (∞  12　*　24  60  60)
　　　　(年 月　日 時　分　秒)

　日のcarryだけが複雑になっている。今の閏年は2/29に集中している。

　(monthmax 月 年)が*を決める。しかし変わるのは2月だけ。

　順番に作っていく(+しか考えていない)ので、年が変わるごとに、このmax表を作り直して、
　maxesはこの表を参照するようにする(効率化)
　
　(* 2 29 * * *)がきたときnormalizeすると(* 3 1 * * *)か(* 2 29 * * *)のどちらかになる。
　と考えると、もうすこし単純にならないか?

　年が決まると2/29のうむが決まるので、年ごとにmaxesが違ってくると考えたほうが単純になるのか・・・

　無駄にややこしく考えているだけかも。


2021/10/10日
maxtableという名前で、maxesを考える。
月ごと(年)にmaxtableを作成し、それを元にnormalize-dtをするようにする

月のない2月のmaxは決まらないが、そういうものだ。

年ごとにmaxtableを作るとすると、年を超えるタイムスタンプの生成を考えると
そういうタイミングでmaxtableを作らないとならぬ。

day1とday2の年が違っていたら、たとえばplus-dayしたとき、3ヶ月の間隔でデータを作っていると
2月がはいるので、おかしくなるかも。

・(Y M D h m s)の固定で作り直した。itoもあわせて修正。
　月、日は0開始にした。
　maxesをパラメタでとるようにした。


(normalize-dt dt)で、

・(format-year)で月と日に+1するようにした。
・model101.lispを調整した。

・2行目先頭のiは、write-logのformatのミス

model102.lispを作った
モデルにループがあると処理もループする

2021/10/11
・modelの処理が終わらないのは、1つのデータの桁数が何十にもなったときにおこっていた。
modelの定義でむやみと大きな値をとらないように変更して終了するようになった。
モデルにるーぷがあることは問題ではない。


