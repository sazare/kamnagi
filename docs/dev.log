
2021/09/26
・ito-nstepsを追加した
　繰り返しito-kamnagi.lispをloadすると、ito-countupの結果が狂ってエラーになった。
　それは当然。気をつけよう

　ito-nsetpsでは、一回のstep-modelで、すべてのportの計算が終わった。
　mod1のcompoの順番を逆にすると、おきない。
　つまり、portの値の変化が次のcompoの実行に影響してしまっている。
　順番に依存しないようにしたいならば、
　portの値は、step-modelを実行する前の値を使わなくてはならない。
　それとも、これでよいと考えられるのか?　compoの順に値が波及していくところを見たいのでNO

　compoの計算結果は一旦keepしておいて、step-modelのあとにそれをportに設定するのがよさそう。
　あるいはstep-modelの前の値をbackupして、step-model/step-compoの計算中のinput側の値は
　そこから参照するようにするか
  一旦残しておくのはめんどうなので、propertyに置くことにしよう。

　apres : あとの値、avant: 前の値

　apresだと、compoの計算結果をいったんそこに置くことになる。
　そして、skip-modelの最後にapresの値をportのvalueとして設定する。
　このportは*portlist*でなくcompoのoutput(input)にあがっているportになるので
  step-modelでは要素のcompoのinputまたはoutputを管理する必要がありそう。

　ならば、*portlist*の全portについてこの操作をすればよい。
　　portが10000個くらいあって、compoで使うのがそのうちの数10個だと効率が悪いが・・・
　　
  apresの場合は、step-modelの最後に*portlist*のすべてについて
    multiple-value-setのとき、valueでなくproperty apresに設定し
　　step-modelの最後に apresからvalueに設定しなおす

　avantの場合は、step-modelの最初に*portlist*のすべてのportについて
　  valueをavantに設定し、
　　inputの値はvalueでなくavantからとってくるようにする。
　　collectvalueの参照先をかえる。

　collectvalueがすでにあるので、avantのほうが修正は少なくてよいようなきがする。
  collectvalueはcompoの中でなく、step-modelでやらなくてはならない。

　defcompoでmultiple-value-setしているところをどうにかするのかな

　問題点は2つ。
　1. step-modelの前後のどちからで値をkeepし、step-modelの期間中の順番を無効にする
　2. step-compoもその影響をうける

** collectvaluesを作っているので、outputをbackupするよりinputをbackupするほうが多少よさそう

step-model起動時のportの値を格納するプロパティ名は
 :before
にする。

にもかかわらず、ito-nstepsの結果はかわらず


2021/09/27
ito-nsteps の結果がかわらないのは、beforeに設定した値をstep-compoで参照していないからだろう
collectvaluesをget-beforesという名前にして:beforeから値をとってくるようにした。

この修正で、ito-kamnagi.lispの前の方のitoで、step-compoをしていたところは
:beforeが必要になるのでstep-modelに置き換えた


* この修正の問題点
　ito-loop1のように、step-model中に変更された値p32,p33をほかで参照していたら
　その値はbeforeになってしまう。
 
2021/09/29
夜、寝ている時に気づいたが、今の動作で正解なので、意図を訂正した

beforeという名前はよいのか、迷い中。




