
2021/09/26
・ito-nstepsを追加した
　繰り返しito-kamnagi.lispをloadすると、ito-countupの結果が狂ってエラーになった。
　それは当然。気をつけよう

　ito-nsetpsでは、一回のstep-modelで、すべてのportの計算が終わった。
　mod1のcompoの順番を逆にすると、おきない。
　つまり、portの値の変化が次のcompoの実行に影響してしまっている。
　順番に依存しないようにしたいならば、
　portの値は、step-modelを実行する前の値を使わなくてはならない。
　それとも、これでよいと考えられるのか?　compoの順に値が波及していくところを見たいのでNO

　compoの計算結果は一旦keepしておいて、step-modelのあとにそれをportに設定するのがよさそう。
　あるいはstep-modelの前の値をbackupして、step-model/step-compoの計算中のinput側の値は
　そこから参照するようにするか
  一旦残しておくのはめんどうなので、propertyに置くことにしよう。

　apres : あとの値、avant: 前の値

　apresだと、compoの計算結果をいったんそこに置くことになる。
　そして、skip-modelの最後にapresの値をportのvalueとして設定する。
　このportは*portlist*でなくcompoのoutput(input)にあがっているportになるので
  step-modelでは要素のcompoのinputまたはoutputを管理する必要がありそう。

　ならば、*portlist*の全portについてこの操作をすればよい。
　　portが10000個くらいあって、compoで使うのがそのうちの数10個だと効率が悪いが・・・
　　
  apresの場合は、step-modelの最後に*portlist*のすべてについて
    multiple-value-setのとき、valueでなくproperty apresに設定し
　　step-modelの最後に apresからvalueに設定しなおす

　avantの場合は、step-modelの最初に*portlist*のすべてのportについて
　  valueをavantに設定し、
　　inputの値はvalueでなくavantからとってくるようにする。
　　collectvalueの参照先をかえる。

　collectvalueがすでにあるので、avantのほうが修正は少なくてよいようなきがする。
  collectvalueはcompoの中でなく、step-modelでやらなくてはならない。

　defcompoでmultiple-value-setしているところをどうにかするのかな

　問題点は2つ。
　1. step-modelの前後のどちからで値をkeepし、step-modelの期間中の順番を無効にする
　2. step-compoもその影響をうける

** collectvaluesを作っているので、outputをbackupするよりinputをbackupするほうが多少よさそう

step-model起動時のportの値を格納するプロパティ名は
 :before
にする。

にもかかわらず、ito-nstepsの結果はかわらず


2021/09/27
ito-nsteps の結果がかわらないのは、beforeに設定した値をstep-compoで参照していないからだろう
collectvaluesをget-beforesという名前にして:beforeから値をとってくるようにした。

この修正で、ito-kamnagi.lispの前の方のitoで、step-compoをしていたところは
:beforeが必要になるのでstep-modelに置き換えた


* この修正の問題点
　ito-loop1のように、step-model中に変更された値p32,p33をほかで参照していたら
　その値はbeforeになってしまう。
 
2021/09/29
夜、寝ている時に気づいたが、今の動作で正解なので、意図を訂正した

beforeという名前はよいのか、迷い中。

* 夜
まず、portの名前を与えて、その値のリスト(性能情報の一行分)をlistにする。

それを繰り返して、セッション中のlogsをあつめる。すなわち

portの値をlistに取り出して、それをlistにpushしていく。
play-kamnagi.lisp

(defvar logs  (nstep-model 10  *portlist*  mod31))

で10回回転する。

ただし、tsはどうも他の変数と別の扱いをすべきなのかも。
ts自体はどうでもいいので、日付でおきかわるから。
portのtsでも、nstep-modelのnでもよい。
tsをcompoで計算しなくてもよいと思う。
でも、時間によって値が影響をうけるようなcompo/portを作りたい時はts portか
それに似たものが必要になる。
tsが問題なのは、compoの実行後のtsとmodelの途中のtsはひとつずれているということ。

ここまではplay-kamnagi.lispできた。

次は
1. csvファイルに出力する。
　すみ
2. 項目名をつける
　すみ
3. datetime 文字列を生成する
　　formatをあえる。y,m,d,h,mm,ss,msのようなキーワード。
　　順番に生成する。
　　　・月によって日数がかわる。m,dの桁あがり。
　　　・閏年がある。


2021/10/02土
datetimeの生成はややこしい。ので、分割して作っていく。
[ややこしさ]
・1日未満の場合
　　sec,min,hour <24H
　　比較的単純
　　nsecかもしれないが、とりあえず最小はsecとする。

    範囲であり繰り上がりのトリガー
　　sec  0<= sec <60
　　min  0<= min <60
　　hour 0<= hour <24

・1日から年
　- 閏年

　- 月によって日数がかわる
　　1 => 31
　　2 => 28,29 閏年に依存
　　3 => 31
　　4 => 30
　　5 => 31
　　6 => 30
　　7 => 31
　　8 => 31
　　9 => 30
　　10 => 31
　　11 => 30
　　12 => 31

　　にしむくさむらい小の月

・生成は、ある時刻のあと次の時刻をどのような間隔で作るかをコントロールしたいかどうか
　基本は、固定の間隔でよい。
　　例えば、5分間隔なら、0:04, 0:09, 0:14, ... この場合、0:59がその分の中の最後の秒になる。

　固定を変えられる(より実際のデータに近づけたい場合。本当に必要かどうかは不明)
　　次のイベントまでの時間を正規分布で変えられるようにするとすると
　　　(m, s)で、平均の間隔がm、分散がsと指定する。
  この分布を正規以外にしたいか??

　この場合、繰り上がりは実際に計算してみないと、決まらない。

- これらのことから、生成APIに必要なパラメータ
　0-datetime  : 最初の時刻
　間隔指定    : dとか(f, d,s)とか。fは分布におうじて計算する関数
　

　|-- 桁あがりの範囲 --| 今 |-- 間隔内の時間 --|

　　間隔内の時間が0とは限らないのではないか?どの範囲までコントロールしたいか。それは分布で決まるのか?

　　桁あがりで、閏年や月の日数による計算をどうするか



2021/10/03日
・乱数関係はquicklispでcl-randistというのがあった。

thanks to https://github.com/lvaruzza/cl-randist

　このソースの中のtests.lispを動かすとなにかできている。
  (ql:quickload "cl-randist")
　(in-packakge :randist)で使える
　どの関数で正規分布での乱数発生できるのか不明。
　(load "tests.lisp")の中にtest-distがあって、平均と分散を見れるので
  (gen-uniform 100)で、一様分布の乱数が10個作られる

　tests.lispのコメントの中に正規分布ぽいのがある

  (gen-normal 10)で10個作れるが、平均と分散の指定はできないみたい。

 (defun gen-normal (&optional (n 100))
  (genlist #'(lambda (x) (declare (ignore x)) (random-normal)) n))

　1個だけ平均、分散を指定して乱数を作る関数はこれ。
　平均100、分散10の正規分布での乱数は
　 (random-normal 100.0d0 10d0)
　で計算できる。数字末尾のd0は、double floatを示す
　
  (random-uniform)もあるが、こちらは引数なし。

2021/10/07木
・datetimeの生成(制限付き)を作った
　うるう年とか大の月小の月などは無視し、year-monの部分は固定で日以下だけをインクリメントする
day.lispを作った。

・day+dayは作ったが、day-dayは逆向きのキャリーが発生するので未対応。
　当初の制約条件的な正規化のほうがよかっただろうか。

・モデルを作ってみる。
   model101.JPG


